import time
import json
import uuid
import jwt
import requests
import websocket
import threading
import pandas as pd
import csv

# ===== ì„¤ì • =====
TOKEN = 'YOUR_TELEGRAM_BOT_TOKEN'
CHAT_ID = 'YOUR_CHAT_ID'
SYMBOL = 'KRW-XRP'
INTERVAL = 14
CANDLE_LIMIT = 200
UPBIT_ACCESS_KEY = 'YOUR_UPBIT_ACCESS_KEY'
UPBIT_SECRET_KEY = 'YOUR_UPBIT_SECRET_KEY'

# ===== ìƒíƒœ =====
price_data = []
active_position = None
paused = False
strategy_id = None
last_strategy = {}

# ===== ìœ í‹¸ í•¨ìˆ˜ =====

def send_signal(message):
    url = f'https://api.telegram.org/bot{TOKEN}/sendMessage'
    data = {'chat_id': CHAT_ID, 'text': message}
    requests.post(url, data=data)

def get_upbit_balance(currency='KRW'):
    payload = {'access_key': UPBIT_ACCESS_KEY, 'nonce': str(uuid.uuid4())}
    jwt_token = jwt.encode(payload, UPBIT_SECRET_KEY)
    headers = {"Authorization": f"Bearer {jwt_token}"}
    res = requests.get("https://api.upbit.com/v1/accounts", headers=headers)
    if res.status_code == 200:
        for b in res.json():
            if b['currency'] == currency:
                return round(float(b['balance']) - float(b['locked']), 2)
    return 0.0

def calculate_rsi(data, period=14):
    df = pd.Series(data)
    delta = df.diff()
    up = delta.clip(lower=0)
    down = -1 * delta.clip(upper=0)
    ma_up = up.rolling(period).mean()
    ma_down = down.rolling(period).mean()
    rsi = 100 - (100 / (1 + (ma_up / ma_down)))
    return round(rsi.iloc[-1], 2)

def classify_strategy(rsi, adx, volume_rate):
    if rsi <= 35 and adx <= 30:
        return "ë‹¨íƒ€í˜•", 3185, 3080, 3310, 3380, 85.3
    elif 35 < rsi <= 50 and 30 < adx <= 35:
        return "ëˆŒë¦¼ ëŒíŒŒí˜•", 2840000, 2800000, 2890000, 2950000, 83.1
    elif rsi > 50 and adx > 35:
        return "ì¶”ì„¸ ì§€ì†í˜•", 3020000, 2980000, 3100000, 3190000, 81.5
    else:
        return "ë³´ë¥˜", None, None, None, None, 0

def adjust_tp(rsi_now, adx_now, volume_now, current_tp):
    if rsi_now > 60 and adx_now > 35 and volume_now > 2.0:
        new_tp = int(current_tp * 1.05)
        send_signal(f"ğŸ“ˆ ìµì ˆ ìƒí–¥ ì œì•ˆ: {current_tp} â†’ {new_tp}")
        return new_tp
    return current_tp

def generate_strategy_id():
    return str(uuid.uuid4())[:8]

def generate_strategy_report(t, entry, stop, tp1, tp2, conf, cash, sid):
    return (
        f"ğŸš¨ ì „ëµ ì¡°ê±´ ì¶©ì¡±!\nì „ëµ ID: {sid}\nì „ëµêµ°: {t}\n"
        f"ì§„ì…ê°€: {entry}ì›\nì†ì ˆê°€: {stop}ì›\nìµì ˆê°€: {tp1} / {tp2}ì›\n"
        f"ì¡°ê±´ ì¶©ì¡±ë„: {conf}%\nì¶”ì²œ ì§„ì… ê¸ˆì•¡: {cash}ì›\nì „ëµ ìœ íš¨ì‹œê°„: 90ë¶„"
    )

def log_result(result_type, exit_price):
    with open("strategy_log.csv", "a", newline='') as f:
        writer = csv.writer(f)
        writer.writerow([
            strategy_id,
            active_position['symbol'],
            active_position['entry'],
            exit_price,
            result_type,
            time.strftime("%Y-%m-%d %H:%M:%S")
        ])
    print("ğŸ“ íšŒê³  ì €ì¥ë¨")

def log_failed_condition(rsi, adx, volume):
    with open("failed_conditions.csv", "a", newline='') as f:
        writer = csv.writer(f)
        writer.writerow([rsi, adx, volume, time.strftime("%Y-%m-%d %H:%M:%S")])
    print("ğŸ“› ì‹¤íŒ¨ ì¡°ê±´ ì €ì¥ë¨")
# ==== ì „ëµ ë¦¬í¬íŠ¸ ìš”ì•½ ====
def generate_summary():
    try:
        df = pd.read_csv("strategy_log.csv", header=None)
        total = len(df)
        wins = len(df[df[3] == "ìµì ˆ"])
        success_rate = round(wins / total * 100, 2)
        send_signal(f"ğŸ“Š ì „ëµ ìš”ì•½\nì´ ì „ëµ: {total}íšŒ\nìµì ˆë¥ : {success_rate}%")
    except:
        send_signal("ğŸ“ íšŒê³  ë¡œê·¸ ì—†ìŒ (ìš”ì•½ ë¶ˆê°€)")

# ==== ì„¤ê³„ì ëª…ë ¹ì–´ ì‘ë‹µ ====
def handle_command(msg):
    global active_position, last_strategy
    if msg in ["ìƒíƒœ", "í¬ì§€ì…˜"]:
        if active_position:
            send_signal(f"ğŸ“Œ í˜„ì¬ í¬ì§€ì…˜\nì§„ì…ê°€: {active_position['entry']}ì›\nìµì ˆê°€: {active_position['tp']}ì›\nì†ì ˆê°€: {active_position['stop']}ì›")
        else:
            send_signal("ğŸ“­ í˜„ì¬ í¬ì§€ì…˜ ì—†ìŒ.")
    elif msg in ["ì „ëµ", "ë§ˆì§€ë§‰ ì „ëµ"]:
        if last_strategy:
            send_signal(f"ğŸ“„ ë§ˆì§€ë§‰ ì „ëµ ìš”ì•½\nì „ëµ ID: {last_strategy['id']}\nêµ°: {last_strategy['type']}\nì§„ì…ê°€: {last_strategy['entry']}ì›")
        else:
            send_signal("ğŸ“ ìµœê·¼ ì „ëµ ì—†ìŒ.")
    elif msg in ["íšŒê³ ", "ìš”ì•½"]:
        generate_summary()

# ==== í…”ë ˆê·¸ë¨ ëª…ë ¹ ê°ì§€ í™•ì¥ ====
def check_command_signal():
    url = f"https://api.telegram.org/bot{TOKEN}/getUpdates"
    response = requests.get(url).json()
    for result in response.get("result", []):
        msg = result.get("message", {}).get("text", "").strip().lower()
        if msg in ["stop", "ê·¸ë§Œí•´", "ë©ˆì¶°"]:
            return "STOP"
        elif msg in ["resume", "ë‹¤ì‹œ ì‹œì‘", "ì‹œì‘í•´"]:
            return "RESUME"
        elif msg in ["ìƒíƒœ", "í¬ì§€ì…˜", "ì „ëµ", "ë§ˆì§€ë§‰ ì „ëµ", "íšŒê³ ", "ìš”ì•½"]:
            handle_command(msg)
    return None

# ==== WebSocket ë©”ì‹œì§€ ì²˜ë¦¬ ====
def on_message(ws, message):
    global price_data, active_position, paused, strategy_id, last_strategy

    cmd = check_command_signal()
    if cmd == "STOP":
        paused = True
        send_signal("ğŸ›‘ ì „ëµ ë£¨í”„ ì •ì§€ë¨ (ì„¤ê³„ì ëª…ë ¹)")
    elif cmd == "RESUME":
        paused = False
        send_signal("â–¶ï¸ ì „ëµ ë£¨í”„ ì¬ì‹œì‘ë¨")

    if paused:
        return

    data = json.loads(message)[0]
    price = float(data['trade_price'])
    price_data.append(price)
    if len(price_data) > CANDLE_LIMIT:
        price_data.pop(0)

    if len(price_data) >= INTERVAL:
        rsi = calculate_rsi(price_data, INTERVAL)
        adx = 31  # ì‹¤ì‹œê°„ ê³„ì‚° ê°€ëŠ¥ í™•ì¥ ê°€ëŠ¥
        volume = 2.1  # ì˜ˆì‹œê°’, ì—°ë™ ê°€ëŠ¥

        print(f"ğŸ“Š í˜„ì¬ê°€: {price} | RSI: {rsi} | ADX: {adx}")

        if not active_position:
            t, entry, stop, tp1, tp2, conf = classify_strategy(rsi, adx, volume)
            if t != "ë³´ë¥˜":
                strategy_id = generate_strategy_id()
                cash = int(get_upbit_balance() * 0.35)
                msg = generate_strategy_report(t, entry, stop, tp1, tp2, conf, cash, strategy_id)
                send_signal(msg)
                active_position = {'symbol': SYMBOL, 'entry': entry, 'stop': stop, 'tp': tp1}
                last_strategy = {'id': strategy_id, 'type': t, 'entry': entry}
        else:
            active_position['tp'] = adjust_tp(rsi, adx, volume, active_position['tp'])

            if price <= active_position['stop']:
                send_signal(f"âŒ ì†ì ˆ ë„ë‹¬: {price}ì› â†’ ì „ëµ ì¢…ë£Œ")
                log_result("ì†ì ˆ", price)
                log_failed_condition(rsi, adx, volume)
                active_position = None
            elif price >= active_position['tp']:
                send_signal(f"âœ… ìµì ˆ ë„ë‹¬: {price}ì› â†’ ì „ëµ ì¢…ë£Œ")
                log_result("ìµì ˆ", price)
                active_position = None
                generate_summary()

# ==== WebSocket ì—°ê²° ì„¤ì • ====
def on_open(ws):
    print("âœ… WebSocket ì—°ê²°ë¨")
    payload = [{"ticket": "gpt-loop"}, {"type": "trade", "codes": [SYMBOL]}]
    ws.send(json.dumps(payload))

# ==== ì‹¤í–‰ ì‹œì‘ ====
def run_websocket():
    url = "wss://api.upbit.com/websocket/v1"
    ws = websocket.WebSocketApp(url, on_open=on_open, on_message=on_message)
    ws.run_forever()

print("â–¶ GPT ìë™ ì „ëµ ì‹œìŠ¤í…œ (Ver.2.0 í™•ì¥ ìµœì¢…íŒ) ê°€ë™ ì‹œì‘")
threading.Thread(target=run_websocket).start()
